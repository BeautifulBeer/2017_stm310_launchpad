#include "stm32f10x_rcc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_tim.h"
#include "misc.h"

static int led_status = 1;

void SysInit(void) {
   /* Set HSION bit */
   /* Internal Clock Enable */
   RCC->CR |= 0x00000001;

   /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
   RCC->CFGR &= 0xF0FF0000;

   /* Reset HSEON, CSSON and PLLON bits */
   RCC->CR &= 0xFEF6FFFF;

   /* Reset HSEBYP bit */
   RCC->CR &= 0xFFFBFFFF;

   /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
   RCC->CFGR &= 0xFF80FFFF;

   /* Reset PLL2ON and PLL3ON bits */
   RCC->CR &= 0xEBFFFFFF;

   /* Disable all interrupts and clear pending bits  */
   RCC->CIR = 0x00FF0000;

   /* Reset CFGR2 register */
   RCC->CFGR2 = 0x00000000;
}

void SetSysClock(void) //40MHz
{
   volatile int StartUpCounter = 0, HSEStatus = 0;

   /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/
   /* Enable HSE */
   RCC->CR |= (RCC_CR_HSEON);

   /* Wait till HSE is ready and if Time out is reached exit */
   do
   {
      HSEStatus = RCC->CR & RCC_CR_HSERDY;
      StartUpCounter++;
   } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));

   if ((RCC->CR & RCC_CR_HSERDY) != RESET)
   {
      HSEStatus = 0x01;
   }
   else
   {
      HSEStatus = 0x00;
   }

   if (HSEStatus == 0x01)
   {
      /* Enable Prefetch Buffer */
      FLASH->ACR |= FLASH_ACR_PRFTBE;

      /* Flash 0 wait state */
      FLASH->ACR &= (~FLASH_ACR_LATENCY);
      FLASH->ACR |= FLASH_ACR_LATENCY_0;

      /* HCLK = SYSCLK / 2 */
      RCC->CFGR |= RCC_CFGR_HPRE_DIV2;

      /* PCLK2 = HCLK / 2 */
      RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;

      /* PCLK1 = HCLK */
      RCC->CFGR |= RCC_CFGR_PPRE1_DIV1;

      /* Configure PLLs ------------------------------------------------------*/
      /* PLL configuration: PLLCLK = PREDIV1 * 5 = 40MHz */
      RCC->CFGR &= ~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
      RCC->CFGR |= (RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |
            RCC_CFGR_PLLMULL5);

      /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40MHz */
      /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8MHz */
      RCC->CFGR2 &= (~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
            RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC));
      RCC->CFGR2 |= (RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
            RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);

      /* Enable PLL2 */
      RCC->CR |= RCC_CR_PLL2ON;
      /* Wait till PLL2 is ready */
      while((RCC->CR & RCC_CR_PLL2RDY) == 0)
      {
      }

      /* Enable PLL */
      RCC->CR |= RCC_CR_PLLON;

      /* Wait till PLL is ready */
      while((RCC->CR & RCC_CR_PLLRDY) == 0)
      {
      }

      /* Select PLL as system clock source */
      RCC->CFGR &= (~(RCC_CFGR_SW));
      RCC->CFGR |= RCC_CFGR_SW_PLL;

      /* Wait till PLL is used as system clock source */
      while ((RCC->CFGR & RCC_CFGR_SWS) != 0x08)
      {
      }
   }
   else
   { /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
   }
}




void NVIC_Configuration(void){
   NVIC_InitTypeDef NVIC_Initstructure;
   NVIC_Initstructure.NVIC_IRQChannel = TIM2_IRQn;
   NVIC_Initstructure.NVIC_IRQChannelPreemptionPriority = 0;
   NVIC_Initstructure.NVIC_IRQChannelSubPriority = 0;
   NVIC_Initstructure.NVIC_IRQChannelCmd = ENABLE;
   NVIC_Init(&NVIC_Initstructure);
}

void InterruptEnable(){
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);//Interrupt
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);//TIM2
}

void mcu_output(){
   GPIO_InitTypeDef InitStructure;
   InitStructure.GPIO_Pin = GPIO_Pin_8;
   InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   GPIO_Init(GPIOA, &InitStructure);

}

void TIM2_IRQHandler(void)
{

   if(led_status){
      GPIO_SetBits(GPIOD,GPIO_Pin_3);
      led_status=0;
   }else{
      GPIO_ResetBits(GPIOD,GPIO_Pin_3);
      led_status=1;
   }
   TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
}

/*
void delay(int i){
   int j;
   for(j=0; j<=i * 100000; j++);
}
*/

void TIM_configuration(){
   TIM_TimeBaseInitTypeDef TIM_TimeBase_Structure;

   TIM_TimeBase_Structure.TIM_Period = 2000;
   TIM_TimeBase_Structure.TIM_Prescaler = 10000;
   TIM_TimeBase_Structure.TIM_ClockDivision = TIM_CKD_DIV1;
   TIM_TimeBase_Structure.TIM_CounterMode = TIM_CounterMode_Up;
   TIM_TimeBaseInit(TIM2, &TIM_TimeBase_Structure);

   TIM_Cmd(TIM2,ENABLE);
   TIM_ITConfig(TIM2,TIM_IT_Update, ENABLE);


}
void Configure_LED() {
   GPIO_InitTypeDef GPIO_init;

   RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);

   GPIO_init.GPIO_Mode = GPIO_Mode_Out_PP;
   GPIO_init.GPIO_Pin = (GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7);
   GPIO_init.GPIO_Speed = GPIO_Speed_50MHz;

   GPIO_Init(GPIOD, &GPIO_init);
}

int main(){
   SysInit();
   SetSysClock();
   InterruptEnable();
   NVIC_Configuration();
   TIM_configuration();
   Configure_LED();
   //mcu_output();
   //GPIOD->BSRR = GPIO_BSRR_BS3;

   while(1){
   }
}

